What it does:

mongoose.connections is an array of all connections that Mongoose has created.

mongoose.connections[0] is the default connection.

.readyState tells you the state of the connection:

    0 â†’ disconnected
    1 â†’ connected
    2 â†’ connecting
    3 â†’ disconnecting


mongoose.connections

mongoose maintains an internal array called connections.
Every time you call mongoose.connect(...), it creates a new connection object and stores it inside this array.

So:
connections[0] â†’ the first/default connection (the one you usually use).
connections[1], connections[2], ... â†’ additional connections if you open multiple DBs.


2. connections[0].readyState

Each connection object has a property readyState which shows the status of the connection.
The possible values are:

0 â†’ disconnected
1 â†’ connected
2 â†’ connecting
3 â†’ disconnecting

if (mongoose.connections[0].readyState) return;
It means:
If there is already an active/connecting connection (readyState !== 0),
then donâ€™t try to connect again â†’ just return.


3. Why do we need this check?

In Next.js (and similar frameworks):

The server code can run multiple times (especially in development with hot-reloads, or in serverless deployments like Vercel where functions spin up frequently).

If you call mongoose.connect() every time without checking, youâ€™ll create multiple duplicate connections to MongoDB â†’ which can:

Slow down performance.
Cause memory leaks.
Even crash your app with too many connections.

So the check ensures:
If a connection already exists, reuse it instead of opening a new one.


Why would mongoose.connections[1], [2]... exist?

Normally, you only need one database connection (connections[0]).
You can define multiple schemas/models on that single connection â†’ one DB handles everything.
connections[1], connections[2], etc. only appear if you intentionally connect to different databases



âœ… So for your case (SonicEdge project):

You donâ€™t need multiple databases.

You just connect once (thatâ€™s connections[0]) to sonicEdgeDB.
Then create multiple schemas/models for:

Products

Users

Orders

Payments

Playlists (if you add Spotify-like features later ğŸ˜‰)

All these live inside the same database.





mongoose.connect(uri, { 
  useNewUrlParser: true, 
  useUnifiedTopology: true 
});

useNewUrlParser explaination : 
    1. What is a Parser in General?
    A parser is something that takes a string (raw text) and breaks it into structured data your program can understand.
    For MongoDB, the connection string (URI) is just text, e.g.:  mongodb://username:password@localhost:27017/myDB?authSource=admi

    The parserâ€™s job is to take that string and break it into:

    Protocol â†’ mongodb://
    Username â†’ username
    Password â†’ password
    Host â†’ localhost
    Port â†’ 27017
    Database â†’ myDB
    Options â†’ { authSource: "admin" }
    So Mongoose (via the MongoDB driver) knows how to connect.




    ğŸ”¹ 2. The Old Parser

        The old parser in the MongoDB driver had problems:
        Couldnâ€™t handle special characters (@, :, %) in passwords.
        Couldnâ€™t properly read SRV connection strings (used in Atlas).
        Struggled with multiple hosts for replica sets.
        Example that could fail âŒ (with old parser):
        const uri = "mongodb://user:pa@ss@localhost:27017/myDB"

        The parser would think pa@ss means the password ended at the @, which is wrong.


    3. The New Parser (useNewUrlParser: true)

        The new parser was rewritten to fully follow the MongoDB URI specification
        Correctly handles special characters (percent-encoded).
        Understands modern formats (mongodb+srv:// for DNS seed lists).
        Handles replica sets and query options properly.
        Example âœ… (with new parser):
        const uri = "mongodb://user:pa%40ss@localhost:27017/myDB";

        Here %40 is the encoded form of @.
        The new parser knows %40 = @ â†’ so your password is correctly parsed as pa@ss.




    4. Atlas Example (SRV Records)

        Atlas gives you URIs like this:
        mongodb+srv://cluster0.mongodb.net/myDB

        Old parser âŒ â†’ doesnâ€™t understand +srv.
        New parser âœ… â†’ does a DNS lookup to find all hosts in the cluster.
        So, with useNewUrlParser: true, you could do:


    Since Mongoose v6+, the new parser is always used by default.
    So you no longer need to specify useNewUrlParser: true.





useUnifiedTopology: true explaination 

What is useUnifiedTopology?

MongoDBâ€™s Node.js driver (which Mongoose uses under the hood) used to have multiple internal engines to manage how it connects to servers (called topology engines):

Old engines:
    Mongos (for sharded clusters)
    ReplSet (for replica sets)
    Server (for standalone servers)
    Each had slightly different logic, which sometimes caused bugs, unnecessary events, and inconsistent behavior.
    Unified Topology Engine:
    A new, single engine introduced in the driver (v3.2+) to handle all server types consistently.

    So, useUnifiedTopology: true tells Mongoose:
    ğŸ‘‰ â€œUse the new unified topology layer instead of the old ones.â€

    


ğŸ”¹ 2. Why is it Useful?

    Makes connection handling more stable.
    Removes deprecation warnings like:

    DeprecationWarning: current Server Discovery and Monitoring engine is deprecated, 
    and will be removed in a future version.

    Provides better server monitoring (detects when nodes in a cluster go up/down more reliably).

    Handles retryable writes and failovers more gracefully.



    Today (Mongoose â‰¥ 6.x)

    You donâ€™t need to specify it anymore â†’ unified topology is always on by default.
    So the simplest way now is:




    Difference between Database and Schema (Mongoose Model)

In MongoDB:

A Database is like a container (e.g., sonicEdgeDB).

Inside it you have Collections (like products, users, orders).

Inside collections, you have Documents (actual JSON objects).

In Mongoose:

A Schema is the blueprint/shape for documents inside a collection.

A Model is a wrapper created from a schema that maps to a collection.







what is the purpose of route.js (api/products/route.js)

CODE : 
import { NextResponse } from "next/server";
import connectDB from "@/lib/mongodb";
import Product from "@/lib/models/Product";

export async function GET(request){
    await connectDB();
    const {searchParams} = new URL(request.url);
    const category = searchParams.get("category");

    try{
        let products;

        if(category){
            products = await Product.find({category});
        }else{
            products = await Product.find({});
        }
        return NextResponse.json(products);
    }catch(err){
        return NextResponse.json({error : err.message} , {status : 500});
    }

}


EXPLAINATION : 
ğŸ‘‰ In simple words:
        This is an API route that connects to MongoDB and returns products.
        If a category is specified â†’ fetch only products in that category.
        If no category is specified â†’ fetch all products.


ğŸ”¹ What is route.js in Next.js?
        In Next.js (App Router), route.js (or route.ts) is used to define API endpoints.
        It works similar to Express.js routes, but itâ€™s built-in to Next.js.
        Instead of making a separate backend server, you can write backend APIs inside your Next.js project itself.


ğŸ”¹ Purpose of route.js
        It allows you to handle server-side logic (fetching data, connecting to DB, authentication, etc.).
        It provides API endpoints that frontend code (React components, fetch, axios, etc.) can call.
        It makes Next.js a full-stack framework (frontend + backend in one project).


ğŸ”¹ Example Use Cases of route.js
1. Fetch Products (your case):
CODE:
    // app/api/products/route.js
export async function GET() {
   return NextResponse.json([
     { id: 1, name: "Guitar" },
     { id: 2, name: "Drums" }
   ]);
}


2. Create a New Product (POST)

CODE :
export async function POST(request) {
   const body = await request.json();
   const newProduct = { id: Date.now(), ...body };
   return NextResponse.json(newProduct, { status: 201 });
}
â¡ï¸ Now frontend can send a POST request:
await fetch("/api/products", {
  method: "POST",
  body: JSON.stringify({ name: "Piano" })
});


3. Authentication
CODE:
// app/api/login/route.js
export async function POST(request) {
   const { email, password } = await request.json();
   if(email === "admin@test.com" && password === "1234") {
      return NextResponse.json({ message: "Login success" });
   }
   return NextResponse.json({ error: "Invalid credentials" }, { status: 401 });
}
â¡ï¸ Used for handling login/signup directly in Next.js.


4. Example with Query Params

You already used this, e.g.
/api/products?category=guitar

Your route.js reads the query and filters products.


In summary:

route.js turns your Next.js project into a full-stack app by handling server-side APIs.
Itâ€™s the backend part of Next.js where you can connect to DB, fetch data, handle auth, etc.
Frontend (/pages or app/) calls these routes using fetch or axios.



ğŸ”¹ WHAT IS NEXTRESPONSE?

NextResponse is a helper class provided by Next.js (App Router) to create and control HTTP responses inside route handlers and middleware.
Itâ€™s like the res object in Express.js, but specifically designed for Next.js.

It allows you to:
Send back JSON, text, or HTML responses.
Set status codes (e.g., 200, 404, 500).
Set cookies and headers.
Redirect users.
Rewrite URLs.

ğŸ‘‰ Basically: NextResponse = Response object (Web API) + Next.js 




FETCH URL EXPLAINATION IN VIEWALL CODE :

  useEffect(() => {
    const fetchProducts = async () => {

      try {
        const res = await fetch(`/api/products?category=${props.contName}`);
        const data = await res.json();
        setProducts(data);
      }catch(err){
        console.log("Error while fetching the products in ViewAll component!");
      }
      
    };

    fetchProducts();
  }, [props.contName]);


WHY YOU DIDNâ€™T MENTION THE FILE NAME (ROUTE.JS)

In Next.js App Router, the file must be named route.js (or route.ts).
The folder name (e.g., products) decides the API endpoint path.
Next.js automatically looks for route.js inside that folder to handle requests.

app/
 â””â”€â”€ api/
      â””â”€â”€ products/
           â””â”€â”€ route.js
           â¡ï¸ The API endpoint becomes:
                /api/
                
ğŸ”¹ WHAT IF YOU HAD MULTIPLE FILES LIKE

app/
 â””â”€â”€ api/
      â””â”€â”€ products/
           â””â”€â”€ route.js       <-- /api/products
           â””â”€â”€ details/
                â””â”€â”€ route.js  <-- /api/products/details
           â””â”€â”€ stats/
                â””â”€â”€ route.js  <-- /api/products/stats

                Only one route.js is allowed per folder.
                If you want multiple endpoints, you create subfolders with their own route.js.

